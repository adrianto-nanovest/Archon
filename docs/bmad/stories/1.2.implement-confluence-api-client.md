# Story 1.2: Implement Confluence API Client Wrapper

## Status
Done

## Story

**As a** backend developer,
**I want** to create `ConfluenceClient` class using `atlassian-python-api` SDK,
**so that** sync services can authenticate and query Confluence Cloud REST API v2.

## Acceptance Criteria

1. File `python/src/server/services/confluence/confluence_client.py` created with ConfluenceClient class
2. Constructor accepts: base_url (str), api_token (str), email (str)
3. Method `async def cql_search(cql: str, expand: str, limit: int)` returns list of pages
4. Method `async def get_page_by_id(page_id: str, expand: str)` returns single page with metadata
5. Method `async def get_space_pages_ids(space_key: str)` returns lightweight page ID list (deletion detection)
6. Exponential backoff retry logic (max 3 retries, 1s/2s/4s delays) on rate limit errors (429)
7. Custom exceptions: `ConfluenceAuthError`, `ConfluenceRateLimitError`, `ConfluenceNotFoundError`

## Tasks / Subtasks

- [x] **Task 1: Create Confluence Services Directory Structure** (AC: 1)
  - [x] Create directory `python/src/server/services/confluence/`
  - [x] Create `__init__.py` with module exports
  - [x] Add directory to pytest discovery paths

- [x] **Task 2: Implement ConfluenceClient Class Constructor** (AC: 1, 2)
  - [x] Create `confluence_client.py` file with ConfluenceClient class
  - [x] Implement `__init__(self, base_url: str, api_token: str, email: str)` constructor
  - [x] Initialize `atlassian.Confluence` client instance with token authentication
  - [x] Add type hints for all parameters and return types
  - [x] Add Google-style docstrings for class and constructor

- [x] **Task 3: Implement CQL Search Method** (AC: 3)
  - [x] Create `async def cql_search(cql: str, expand: str = None, limit: int = 1000)` method
  - [x] Call `self.client.cql()` with CQL query and expansion parameters
  - [x] Handle pagination if results exceed limit (fetch all pages up to limit)
  - [x] Return list of page dictionaries with requested expanded fields
  - [x] Add docstring with CQL query examples: `space = DEVDOCS AND lastModified >= "2025-10-01 10:00"`

- [x] **Task 4: Implement Get Page by ID Method** (AC: 4)
  - [x] Create `async def get_page_by_id(page_id: str, expand: str = None)` method
  - [x] Call `self.client.get_page_by_id()` with page_id and expand parameters
  - [x] Return single page dictionary with full metadata
  - [x] Raise `ConfluenceNotFoundError` if page does not exist (404)
  - [x] Add docstring with expand examples: `body.storage,version,ancestors`

- [x] **Task 5: Implement Get Space Page IDs Method** (AC: 5)
  - [x] Create `async def get_space_pages_ids(space_key: str)` method
  - [x] Call `self.client.get_all_pages_from_space()` with expand=None for lightweight fetch
  - [x] Extract and return list of page IDs only (no content or metadata)
  - [x] Handle pagination to fetch all page IDs in space (may be 4000+)
  - [x] Add docstring noting this is for deletion detection (minimal API overhead)

- [x] **Task 6: Define Custom Exception Classes** (AC: 7)
  - [x] Create `ConfluenceAuthError(Exception)` for authentication failures (401)
  - [x] Create `ConfluenceRateLimitError(Exception)` for rate limit hits (429)
  - [x] Create `ConfluenceNotFoundError(Exception)` for missing resources (404)
  - [x] Add error message field to each exception for debugging context
  - [x] Document exceptions in module docstring with usage examples

- [x] **Task 7: Implement Exponential Backoff Retry Logic** (AC: 6)
  - [x] Create `_retry_with_backoff()` helper method (private)
  - [x] Implement exponential backoff: 1s, 2s, 4s delays for max 3 retries
  - [x] Catch `ConfluenceRateLimitError` (429) and trigger retry
  - [x] Re-raise error after max retries exceeded
  - [x] Log retry attempts with delay duration and attempt number
  - [x] Wrap all API calls (cql_search, get_page_by_id, get_space_pages_ids) with retry logic

- [x] **Task 8: Add Error Handling and Logging** (AC: 7)
  - [x] Wrap all `atlassian-python-api` calls with try/except blocks
  - [x] Map HTTP status codes to custom exceptions (401→Auth, 429→RateLimit, 404→NotFound)
  - [x] Log all API errors with `exc_info=True` for stack traces
  - [x] Log successful API calls at DEBUG level with request details (CQL query, page_id, space_key)
  - [x] Add error context (base_url, operation type) to exception messages

- [x] **Task 9: Write Unit Tests for ConfluenceClient** (Testing section)
  - [x] Create `python/tests/server/services/confluence/test_confluence_client.py`
  - [x] Test constructor initialization with valid credentials
  - [x] Test CQL search with mock Confluence responses (successful and paginated)
  - [x] Test get_page_by_id with mock page data
  - [x] Test get_space_pages_ids with mock space data (1000+ pages)
  - [x] Test exponential backoff retry logic (mock 429 errors)
  - [x] Test custom exception handling (401, 404, 429)
  - [x] Use pytest fixtures for mock Confluence client
  - [x] Use pytest.mark.asyncio for async test functions

- [x] **Task 10: Create Integration Tests** (Testing section)
  - [x] Create `python/tests/integration/test_confluence_client_integration.py`
  - [x] Test authentication with test Confluence Cloud instance (requires test API token)
  - [x] Test CQL query returns expected pages matching lastModified filter
  - [x] Test rate limit handling gracefully waits and retries without crashing
  - [x] Mark as `@pytest.mark.integration` to separate from unit tests
  - [x] Add README note on how to run integration tests (requires CONFLUENCE_TEST_URL and CONFLUENCE_TEST_TOKEN)

## Dev Notes

### Previous Story Insights
- **Story 1.1 Completion**: Migration 010 successfully created with Hybrid Schema approach
  - `confluence_pages` table established with all indexes
  - Database foundation ready for API client integration
  - Self-recording migration pattern validated
  - Testing infrastructure established (pytest with async support)

### Architecture Context: Confluence Integration Strategy

**Source:** [Architecture: Confluence Integration](docs/bmad/brownfield-architecture/confluence-integration-architecture.md)

#### Hybrid Schema Approach
The Confluence integration uses a **Hybrid database schema** combining:
1. Dedicated `confluence_pages` table for rich metadata (~15 KB per page)
2. **REUSE** of existing `archon_crawled_pages` table for chunks (unified storage)
3. Link via `metadata->>'page_id'` with indexed lookup

**Why This Matters for API Client:**
- Client must fetch complete page metadata for `confluence_pages` storage
- Client must support lightweight page ID fetching for deletion detection
- API client design optimizes for 90% code reuse downstream

#### CQL-Based Incremental Sync Strategy

**Source:** [Architecture: Confluence Integration - CQL Strategy](docs/bmad/brownfield-architecture/confluence-integration-architecture.md#cql-based-incremental-sync-strategy)

**No full space scans!** Confluence syncs use CQL (Confluence Query Language) to fetch only changed pages:

```python
# Example CQL query pattern
cql = f'space = {space_key} AND lastModified >= "{last_sync_timestamp}"'
changed_pages = confluence_client.cql_search(cql, expand='body.storage,version,ancestors')
```

**API Client Requirements:**
- `cql_search()` method must support CQL queries with `lastModified` filters
- Must handle pagination (4000+ pages require multiple API calls)
- Expand parameter controls metadata depth (body.storage for content, version for incremental sync, ancestors for hierarchy)

#### Deletion Detection Strategies

**Source:** [Architecture: Confluence Integration - CQL Strategy](docs/bmad/brownfield-architecture/confluence-integration-architecture.md#cql-based-incremental-sync-strategy)

Three deletion detection modes:
- `weekly_reconciliation` (default): Check for deletions once per week
- `every_sync`: Check every sync (1 API call per 1000 pages)
- `on_demand`: Never check during sync (user notices 404s)

**API Client Impact:**
- `get_space_pages_ids()` method must be lightweight (no body content, no metadata)
- Supports deletion detection with minimal API overhead
- Expected to handle 4000+ page IDs efficiently

### API Integration Pattern

**Source:** [Architecture: Integration Points](docs/bmad/brownfield-architecture/integration-points-and-external-dependencies.md#confluence-api-integration-to-implement)

**Confluence REST API v2 Documentation:**
- API: https://developer.atlassian.com/cloud/confluence/rest/v2/intro/
- CQL: https://developer.atlassian.com/cloud/confluence/advanced-searching-using-cql/
- SDK: `atlassian-python-api` (https://atlassian-python-api.readthedocs.io/)

**Authentication Pattern:**
```python
from atlassian import Confluence

class ConfluenceClient:
    def __init__(self, base_url: str, api_token: str, email: str):
        # Token authentication for Confluence Cloud
        self.client = Confluence(url=base_url, token=api_token, cloud=True)
```

**Rate Limits (Confluence Cloud Standard):**
- 10 requests/second per API token
- 100,000 requests/day per API token
- HTTP 429 errors trigger exponential backoff

### File Locations and Project Structure

**Source:** [Architecture: Source Tree](docs/bmad/brownfield-architecture/source-tree-and-module-organization.md)

**New Files to Create:**
- `python/src/server/services/confluence/` - New directory
- `python/src/server/services/confluence/__init__.py` - Module exports
- `python/src/server/services/confluence/confluence_client.py` - ConfluenceClient class (~200 lines)

**Project Structure Pattern:**
```
python/src/server/services/
├── knowledge/
│   └── knowledge_item_service.py  # Will use ConfluenceClient in Story 2.x
├── storage/
│   └── document_storage_service.py  # Will chunk Confluence content
├── search/
│   └── hybrid_search_strategy.py  # Will search Confluence chunks
└── confluence/  # NEW: This story creates this directory
    ├── __init__.py
    └── confluence_client.py  # API wrapper (THIS FILE)
```

### Technical Stack and Dependencies

**Source:** [Architecture: High Level](docs/bmad/brownfield-architecture/high-level-architecture.md#actual-tech-stack)

**Language and Framework:**
- Python 3.12 (required for latest typing features)
- FastAPI 0.104+ (async-first framework)
- asyncpg 0.29+ for database access

**New Dependency (Added in Story 1.3):**
- `atlassian-python-api = "^3.41.0"` - Confluence REST API client SDK

**Coding Standards:**
- Type hints required for all function signatures
- Google-style docstrings for public methods
- 120 character line length
- Async-first: All I/O operations use async/await patterns

### Error Handling Strategy

**Source:** [Architecture: High Level](docs/bmad/brownfield-architecture/high-level-architecture.md), [CLAUDE.md](CLAUDE.md#error-handling)

**Beta Development Principle: Fail Fast and Loud**

**Authentication/Authorization Failures (401) → FAIL IMMEDIATELY:**
- Invalid API token must stop execution with `ConfluenceAuthError`
- Log full error context: base_url, email, error message
- Do not retry authentication failures (user must fix credentials)

**Rate Limit Errors (429) → RETRY WITH BACKOFF:**
- Implement exponential backoff: 1s, 2s, 4s delays for max 3 retries
- Log each retry attempt with delay duration
- Fail after max retries with clear rate limit message

**Not Found Errors (404) → RAISE SPECIFIC EXCEPTION:**
- Missing page/space raises `ConfluenceNotFoundError`
- Include page_id or space_key in error message
- Do not retry (resource does not exist)

**Logging Requirements:**
- All errors logged with `exc_info=True` for stack traces
- Include operation context: CQL query, page_id, space_key, base_url
- DEBUG level for successful API calls with request details

### Testing Standards

**Source:** [Architecture: Development and Deployment](docs/bmad/brownfield-architecture/development-and-deployment.md#testing)

**Test Framework:** Pytest with async support

**Test File Locations:**
- Unit tests: `python/tests/server/services/confluence/test_confluence_client.py`
- Integration tests: `python/tests/integration/test_confluence_client_integration.py`

**Test Patterns:**
- Use `pytest.mark.asyncio` for async test functions
- Use `pytest` fixtures for mock Confluence client setup
- Mock `atlassian.Confluence` SDK responses for unit tests
- Separate integration tests with `@pytest.mark.integration` marker

**Required Test Coverage:**
1. **Unit Tests (No External API Calls):**
   - Constructor initialization
   - CQL search with mock responses (success, pagination, rate limit)
   - Get page by ID with mock data
   - Get space page IDs with mock list (1000+ pages)
   - Exponential backoff retry logic (mock 429 errors)
   - Custom exception handling (401, 404, 429 status codes)

2. **Integration Tests (Requires Test Confluence Instance):**
   - Authentication with test Confluence Cloud instance
   - CQL query returns expected pages matching lastModified filter
   - Rate limit handling gracefully waits and retries without crashing
   - **Note:** Integration tests require environment variables: `CONFLUENCE_TEST_URL`, `CONFLUENCE_TEST_TOKEN`

**Running Tests:**
```bash
cd python
uv run pytest tests/server/services/confluence/  # Unit tests only
uv run pytest -m integration  # Integration tests only
uv run pytest  # All tests
```

### Integration Verification Requirements

**From Epic 1 Story 1.2 Acceptance Criteria:**

**IV1: Successfully authenticate with test Confluence Cloud instance using API token**
- Test: Integration test with valid token authenticates successfully
- Validation: `ConfluenceClient` initialization succeeds without exceptions

**IV2: CQL query returns expected pages matching `lastModified` filter**
- Test: CQL search with recent timestamp returns only recently modified pages
- Validation: Returned page list filtered correctly by lastModified date

**IV3: Rate limit handling gracefully waits and retries without crashing**
- Test: Mock 429 errors trigger exponential backoff retry logic
- Validation: After retries, client either succeeds or raises clear rate limit error (no crash)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-14 | 1.0 | Initial story creation from Epic 1 | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
claude-sonnet-4-5-20250929

### Debug Log References
None - Implementation completed without issues requiring debug logging.

### Completion Notes
- Successfully implemented ConfluenceClient wrapper for atlassian-python-api SDK
- Added dependencies: atlassian-python-api>=3.41.0, markdownify>=0.11.0
- All 28 unit tests passing with comprehensive coverage of:
  - Constructor initialization and authentication
  - CQL search with pagination support
  - Get page by ID with metadata expansion
  - Get space page IDs for deletion detection
  - Exponential backoff retry logic (1s, 2s, 4s delays)
  - Custom exception handling (ConfluenceAuthError, ConfluenceRateLimitError, ConfluenceNotFoundError)
  - Error mapping from HTTP status codes (401, 404, 429)
- Integration tests created with environment variable configuration
- All code passes ruff linting and mypy type checking
- Follows async-first patterns with asyncio.to_thread for SDK calls
- Comprehensive Google-style docstrings with examples

### File List
**Created:**
- `python/src/server/services/confluence/__init__.py` - Module exports
- `python/src/server/services/confluence/confluence_client.py` - ConfluenceClient class (270 lines)
- `python/tests/server/services/confluence/__init__.py` - Test module
- `python/tests/server/services/confluence/test_confluence_client.py` - Unit tests (350 lines, 28 tests)
- `python/tests/integration/__init__.py` - Integration test module
- `python/tests/integration/test_confluence_client_integration.py` - Integration tests (270 lines, 12 tests)

**Modified:**
- `python/pyproject.toml` - Added atlassian-python-api and markdownify dependencies to server and all groups

## QA Results

### Review Date: 2025-10-14

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall: EXCELLENT** - This is a textbook implementation of an API client wrapper. The code demonstrates:

- ✅ **Clean Architecture**: Single Responsibility Principle applied consistently
- ✅ **Comprehensive Error Handling**: Custom exceptions with detailed context
- ✅ **Production-Ready Retry Logic**: Exponential backoff with configurable retries
- ✅ **Type Safety**: Full type hints throughout (Python 3.12 features used correctly)
- ✅ **Async-First Design**: Proper use of `asyncio.to_thread` for synchronous SDK calls
- ✅ **Excellent Documentation**: Google-style docstrings with examples
- ✅ **Defensive Programming**: Robust error mapping and logging

The implementation shows strong adherence to the "Fail Fast and Loud" principle from CLAUDE.md while also implementing smart retry logic for transient failures (rate limits).

### Refactoring Performed

**Minor Fix**: Import order correction
- **File**: `python/tests/server/services/confluence/test_confluence_client.py`
- **Change**: Reordered imports (pytest before unittest.mock) to comply with Ruff linting
- **Why**: Maintains consistent import ordering across codebase
- **How**: Used `ruff check --fix` to auto-correct

**No other refactoring needed** - The code is already well-structured and follows best practices.

### Compliance Check

- ✅ **Coding Standards**: PASS
  - 120 character line length adhered to
  - Python 3.12 type hints used correctly
  - Async-first patterns followed
  - Google-style docstrings on all public methods
  - Proper exception hierarchy

- ✅ **Project Structure**: PASS
  - Files created in correct locations per source tree documentation
  - Module organization follows brownfield architecture patterns
  - Test files mirror source structure correctly
  - Integration tests properly separated with markers

- ✅ **Testing Strategy**: PASS
  - 28 comprehensive unit tests (100% pass rate)
  - Mock-based unit tests isolate dependencies
  - Integration tests with proper environment variable guards
  - Edge cases covered (empty results, rate limits, malformed data)
  - Error scenarios thoroughly tested
  - Retry logic validated with timing assertions

- ✅ **All ACs Met**: PASS
  - AC1: ✅ File created with ConfluenceClient class
  - AC2: ✅ Constructor accepts base_url, api_token, email
  - AC3: ✅ `cql_search` method implemented with pagination
  - AC4: ✅ `get_page_by_id` method implemented
  - AC5: ✅ `get_space_pages_ids` method for deletion detection
  - AC6: ✅ Exponential backoff (1s/2s/4s, max 3 retries)
  - AC7: ✅ Custom exceptions (Auth, RateLimit, NotFound)

### Test Coverage Analysis

**Unit Tests** (28 tests, 100% pass):
- ✅ Constructor initialization (2 tests)
- ✅ CQL search success/error paths (6 tests)
- ✅ Get page by ID success/error paths (4 tests)
- ✅ Get space page IDs success/error paths (5 tests)
- ✅ Retry with backoff logic (6 tests)
- ✅ API error handling (5 tests)

**Integration Tests** (12 tests, conditional):
- ✅ Authentication validation
- ✅ Real CQL queries with filters
- ✅ Page retrieval by ID
- ✅ Space page ID listing
- ✅ Rate limit handling (disabled by default)
- ✅ Environment variable guards

**Test Quality Highlights**:
- Mock isolation prevents external API calls in unit tests
- Comprehensive edge case coverage (empty spaces, malformed pages, missing IDs)
- Retry timing verified with `asyncio.sleep` mocks
- Error context validation ensures debugging information
- Integration tests properly marked and skippable

### Security Review

**✅ PASS** - No security concerns identified

**Authentication Security**:
- ✅ API token never logged (masked in logging context)
- ✅ Token passed to SDK securely (password parameter)
- ✅ No token exposure in error messages
- ✅ Authentication failures raise immediately (no retries)

**API Security**:
- ✅ Rate limiting handled gracefully with exponential backoff
- ✅ CQL queries passed to SDK (SDK handles parameterization)
- ✅ No SQL injection risk (CQL is server-side, validated by Confluence)
- ✅ Error messages don't leak sensitive data

**Dependency Security**:
- ✅ `atlassian-python-api>=3.41.0` - Well-maintained SDK
- ✅ `markdownify>=0.11.0` - For future HTML→Markdown conversion
- ⚠️ **Recommendation**: Run `pip-audit` to verify no CVEs (Story 1.4)

**Logging Security**:
- ✅ All errors logged with `exc_info=True` for debugging
- ✅ Sensitive data (API token) excluded from log context
- ✅ Operation context includes non-sensitive identifiers only

### Performance Considerations

**✅ PASS** - Performance optimized for expected usage

**Strengths**:
- ✅ Async design prevents blocking
- ✅ `asyncio.to_thread` correctly used for synchronous SDK calls
- ✅ Pagination support for large result sets
- ✅ Configurable limits prevent unbounded queries
- ✅ Exponential backoff prevents rate limit storms

**Future Optimizations** (not required for MVP):
- Consider connection pooling for high-volume scenarios
- Add caching layer for frequently accessed pages
- Implement batch request optimization for multiple page fetches

**Resource Usage**:
- Memory: Efficient - only loads requested pages
- CPU: Low - simple JSON parsing
- Network: Optimized with pagination and selective expansion
- Rate Limits: Protected by retry logic and intelligent backoff

### Improvements Checklist

- [x] Fixed import order in test file (Ruff auto-fix applied)
- [x] Verified all 28 unit tests pass
- [x] Confirmed Ruff linting passes
- [x] Confirmed MyPy type checking passes (no errors)
- [ ] **Recommended**: Add Story 1.4 (Security Audit) - run pip-audit on new dependencies
- [ ] **Recommended**: Consider adding docstring examples for error handling patterns
- [ ] **Future Enhancement**: Add connection pooling for high-throughput scenarios (not needed for MVP)

### Architecture & Design Patterns

**✅ EXCELLENT** - Demonstrates professional software engineering practices

**Patterns Applied**:
1. **Wrapper Pattern**: Clean abstraction over atlassian-python-api SDK
2. **Decorator Pattern**: `_retry_with_backoff` wraps operations transparently
3. **Strategy Pattern**: Error handling strategy encapsulated in `_handle_api_error`
4. **Async Executor Pattern**: `asyncio.to_thread` for sync SDK calls
5. **Custom Exception Hierarchy**: Specific exceptions for different failure modes

**Design Strengths**:
- Clear separation of concerns (query, error handling, retry logic)
- Testability: Easy to mock and test each component
- Extensibility: Easy to add new methods or expand retry logic
- Maintainability: Self-documenting code with comprehensive docstrings
- SOLID Principles: Single Responsibility, Open/Closed adhered to

### NFR Validation

**Security**: ✅ PASS
- Authentication: Token-based, secure
- Authorization: Delegated to Confluence API
- Data Protection: No sensitive data exposure in logs

**Performance**: ✅ PASS
- Response times: Dependent on Confluence API (typically <500ms)
- Resource usage: Minimal (async design prevents blocking)
- Scalability: Handles 4000+ page spaces efficiently

**Reliability**: ✅ PASS
- Error handling: Comprehensive with custom exceptions
- Recovery: Automatic retry with exponential backoff
- Logging: Detailed context for debugging

**Maintainability**: ✅ PASS
- Code clarity: Excellent docstrings and type hints
- Testability: 28 comprehensive unit tests
- Documentation: Inline examples and usage patterns

### Files Modified During Review

**Modified**:
- `python/tests/server/services/confluence/test_confluence_client.py` - Import order fix (Ruff auto-fix)

**Note**: Please update the File List in the Dev Agent Record to reflect this linting correction if not already included.

### Gate Status

**Gate: PASS** → [docs/qa/gates/1.2-implement-confluence-api-client.yml](../../../qa/gates/1.2-implement-confluence-api-client.yml)

**Risk Profile**: [docs/qa/assessments/1.2-risk-20251014.md](../../../qa/assessments/1.2-risk-20251014.md)

**Summary**: This story implementation is production-ready. All acceptance criteria met, comprehensive test coverage, no blocking issues identified. The code quality exceeds expectations for a foundational API client.

**Quality Score**: 93/100
- Deductions: -5 for pending security audit (Story 1.4), -2 for minor documentation enhancements

### Recommended Status

✅ **Ready for Done**

**Justification**:
- All 7 acceptance criteria fully met
- 28/28 unit tests passing
- Integration tests properly configured
- No critical or high-severity issues
- Code quality exceeds standards
- Security best practices followed
- Performance optimized for expected usage
- Documentation comprehensive and clear

**Next Steps**:
1. Merge to main branch
2. Proceed to Story 1.3 (if not already started)
3. Schedule Story 1.4 (Security Audit) before Epic 2 begins
4. Consider this implementation as a reference pattern for future API clients

### Acknowledgments

**Excellent work by the development team!** This implementation demonstrates:
- Deep understanding of async Python patterns
- Production-grade error handling
- Comprehensive test coverage
- Clear, maintainable code structure

This sets a high bar for the remaining Confluence integration stories.
